{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"zend-inputfilter The zend-inputfilter component can be used to filter and validate generic sets of input data. For instance, you could use it to filter $_GET or $_POST values, CLI arguments, etc. File issues at https://github.com/zendframework/zend-inputfilter/issues Documentation is at https://docs.zendframework.com/zend-inputfilter/","title":"Home"},{"location":"#zend-inputfilter","text":"The zend-inputfilter component can be used to filter and validate generic sets of input data. For instance, you could use it to filter $_GET or $_POST values, CLI arguments, etc. File issues at https://github.com/zendframework/zend-inputfilter/issues Documentation is at https://docs.zendframework.com/zend-inputfilter/","title":"zend-inputfilter"},{"location":"file-input/","text":"File Upload Input The Zend\\InputFilter\\FileInput class is a special Input type for uploaded files found in the $_FILES array. While FileInput uses the same interface as Input , it differs in a few ways: It expects the raw value to be in a normalized $_FILES array format. See the PSR-7 Uploaded files chapter for details on how to accomplish this. Diactoros and zend-http can do this for you. Alternately, you may provide an array of PSR-7 uploaded file instances. The validators are run before the filters (which is the opposite behavior of Input ). This is so that any validation can be run prior to any filters that may rename/move/modify the file; we should not do those operations if the file upload was invalid! Instead of adding a NotEmpty validator, it will (by default) automatically add a Zend\\Validator\\File\\UploadFile validator. The biggest thing to be concerned about is that if you are using a <input type=\"file\"> element in your form, you will need to use the FileInput instead of Input or else you will encounter issues. Basic Usage Usage of FileInput is essentially the same as Input : use Zend\\Http\\PhpEnvironment\\Request; use Zend\\Filter; use Zend\\InputFilter\\InputFilter; use Zend\\InputFilter\\Input; use Zend\\InputFilter\\FileInput; use Zend\\Validator; // Description text input $description = new Input('description'); // Standard Input type // Filters are run first w/ Input $description ->getFilterChain() ->attach(new Filter\\StringTrim()); // Validators are run second w/ Input $description ->getValidatorChain() ->attach(new Validator\\StringLength(['max' => 140])); // File upload input $file = new FileInput('file'); // Special File Input type // Validators are run first w/ FileInput $file ->getValidatorChain() ->attach(new Validator\\File\\UploadFile()); // Filters are run second w/ FileInput $file ->getFilterChain() ->attach(new Filter\\File\\RenameUpload([ 'target' => './data/tmpuploads/file', 'randomize' => true, ])); // Merge $_POST and $_FILES data together $request = new Request(); $postData = array_merge_recursive( $request->getPost()->toArray(), $request->getFiles()->toArray() ); $inputFilter = new InputFilter(); $inputFilter ->add($description) ->add($file) ->setData($postData); if ($inputFilter->isValid()) { // FileInput validators are run, but not the filters... echo \"The form is valid\\n\"; $data = $inputFilter->getValues(); // This is when the FileInput filters are run. } else { echo \"The form is not valid\\n\"; foreach ($inputFilter->getInvalidInput() as $error) { print_r ($error->getMessages()); } } PSR-7 Support Available since version 2.9.0 You may also pass an array of uploaded files from a PSR-7 ServerRequestInterface . use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Filter; use Zend\\InputFilter\\InputFilter; use Zend\\InputFilter\\FileInput; use Zend\\Validator; // File upload input $file = new FileInput('file'); $file ->getValidatorChain() ->attach(new Validator\\File\\UploadFile()); $file ->getFilterChain() ->attach(new Filter\\File\\RenameUpload([ 'target' => './data/tmpuploads/file', 'randomize' => true, ])); // Merge form and uploaded file data together // Unlike the previous example, we get the form data from `getParsedBody()`, and // the uploaded file data from `getUploadedFiles()`. // @var ServerRequestInterface $request $postData = array_merge_recursive( $request->getParsedBody(), $request->getUploadedFiles() ); $inputFilter = new InputFilter(); $inputFilter ->add($file) ->setData($postData); if ($inputFilter->isValid()) { // FileInput validators are run, but not the filters... echo \"The form is valid\\n\"; $data = $inputFilter->getValues(); // This is when the FileInput filters are run. } else { echo \"The form is not valid\\n\"; foreach ($inputFilter->getInvalidInput() as $error) { print_r ($error->getMessages()); } }","title":"File Upload Input"},{"location":"file-input/#file-upload-input","text":"The Zend\\InputFilter\\FileInput class is a special Input type for uploaded files found in the $_FILES array. While FileInput uses the same interface as Input , it differs in a few ways: It expects the raw value to be in a normalized $_FILES array format. See the PSR-7 Uploaded files chapter for details on how to accomplish this. Diactoros and zend-http can do this for you. Alternately, you may provide an array of PSR-7 uploaded file instances. The validators are run before the filters (which is the opposite behavior of Input ). This is so that any validation can be run prior to any filters that may rename/move/modify the file; we should not do those operations if the file upload was invalid! Instead of adding a NotEmpty validator, it will (by default) automatically add a Zend\\Validator\\File\\UploadFile validator. The biggest thing to be concerned about is that if you are using a <input type=\"file\"> element in your form, you will need to use the FileInput instead of Input or else you will encounter issues.","title":"File Upload Input"},{"location":"file-input/#basic-usage","text":"Usage of FileInput is essentially the same as Input : use Zend\\Http\\PhpEnvironment\\Request; use Zend\\Filter; use Zend\\InputFilter\\InputFilter; use Zend\\InputFilter\\Input; use Zend\\InputFilter\\FileInput; use Zend\\Validator; // Description text input $description = new Input('description'); // Standard Input type // Filters are run first w/ Input $description ->getFilterChain() ->attach(new Filter\\StringTrim()); // Validators are run second w/ Input $description ->getValidatorChain() ->attach(new Validator\\StringLength(['max' => 140])); // File upload input $file = new FileInput('file'); // Special File Input type // Validators are run first w/ FileInput $file ->getValidatorChain() ->attach(new Validator\\File\\UploadFile()); // Filters are run second w/ FileInput $file ->getFilterChain() ->attach(new Filter\\File\\RenameUpload([ 'target' => './data/tmpuploads/file', 'randomize' => true, ])); // Merge $_POST and $_FILES data together $request = new Request(); $postData = array_merge_recursive( $request->getPost()->toArray(), $request->getFiles()->toArray() ); $inputFilter = new InputFilter(); $inputFilter ->add($description) ->add($file) ->setData($postData); if ($inputFilter->isValid()) { // FileInput validators are run, but not the filters... echo \"The form is valid\\n\"; $data = $inputFilter->getValues(); // This is when the FileInput filters are run. } else { echo \"The form is not valid\\n\"; foreach ($inputFilter->getInvalidInput() as $error) { print_r ($error->getMessages()); } }","title":"Basic Usage"},{"location":"file-input/#psr-7-support","text":"Available since version 2.9.0 You may also pass an array of uploaded files from a PSR-7 ServerRequestInterface . use Psr\\Http\\Message\\ServerRequestInterface; use Zend\\Filter; use Zend\\InputFilter\\InputFilter; use Zend\\InputFilter\\FileInput; use Zend\\Validator; // File upload input $file = new FileInput('file'); $file ->getValidatorChain() ->attach(new Validator\\File\\UploadFile()); $file ->getFilterChain() ->attach(new Filter\\File\\RenameUpload([ 'target' => './data/tmpuploads/file', 'randomize' => true, ])); // Merge form and uploaded file data together // Unlike the previous example, we get the form data from `getParsedBody()`, and // the uploaded file data from `getUploadedFiles()`. // @var ServerRequestInterface $request $postData = array_merge_recursive( $request->getParsedBody(), $request->getUploadedFiles() ); $inputFilter = new InputFilter(); $inputFilter ->add($file) ->setData($postData); if ($inputFilter->isValid()) { // FileInput validators are run, but not the filters... echo \"The form is valid\\n\"; $data = $inputFilter->getValues(); // This is when the FileInput filters are run. } else { echo \"The form is not valid\\n\"; foreach ($inputFilter->getInvalidInput() as $error) { print_r ($error->getMessages()); } }","title":"PSR-7 Support"},{"location":"intro/","text":"Introduction zend-inputfilter can be used to filter and validate generic sets of input data. For instance, you could use it to filter $_GET or $_POST values, CLI arguments, etc. To pass input data to the InputFilter , use the setData() method; the data must be specified using an associative array. Below is an example on how to validate the data coming from a form using the POST method. use Zend\\InputFilter\\InputFilter; use Zend\\InputFilter\\Input; use Zend\\Validator; $email = new Input('email'); $email->getValidatorChain() ->attach(new Validator\\EmailAddress()); $password = new Input('password'); $password->getValidatorChain() ->attach(new Validator\\StringLength(8)); $inputFilter = new InputFilter(); $inputFilter->add($email); $inputFilter->add($password); $inputFilter->setData($_POST); if ($inputFilter->isValid()) { echo \"The form is valid\\n\"; } else { echo \"The form is not valid\\n\"; foreach ($inputFilter->getInvalidInput() as $error) { print_r($error->getMessages()); } } In this example, we validated the email and password values. The email must be a valid address and the password must be composed of at least 8 characters. If the input data are not valid, we report the list of invalid input using the getInvalidInput() method. You can add validators to each input using the attach() method for each validator chain. It is also possible to specify a \"validation group\", a subset of the data to be validated; this may be done using the setValidationGroup() method. You can specify the list of the input names as an array or as individual parameters. // As individual parameters $inputFilter->setValidationGroup('email', 'password'); // or as an array of names $inputFilter->setValidationGroup(['email', 'password']); You can validate and/or filter the data using the InputFilter . To filter data, use the getFilterChain() method of individual Input instances, and attach filters to the returned filter chain. Below is an example that uses filtering without validation. use Zend\\InputFilter\\Input; use Zend\\InputFilter\\InputFilter; $input = new Input('foo'); $input->getFilterChain() ->attachByName('stringtrim') ->attachByName('alpha'); $inputFilter = new InputFilter(); $inputFilter->add($input); $inputFilter->setData([ 'foo' => ' Bar3 ', ]); echo \"Before:\\n\"; echo $inputFilter->getRawValue('foo') . \"\\n\"; // the output is ' Bar3 ' echo \"After:\\n\"; echo $inputFilter->getValue('foo') . \"\\n\"; // the output is 'Bar' The getValue() method returns the filtered value of the 'foo' input, while getRawValue() returns the original value of the input. We also provide Zend\\InputFilter\\Factory to allow initialization of the InputFilter based on a configuration array or Traversable object. Below is an example where we create a password input value with the same constraints proposed before (a string with at least 8 characters): use Zend\\InputFilter\\Factory; $factory = new Factory(); $inputFilter = $factory->createInputFilter([ 'password' => [ 'name' => 'password', 'required' => true, 'validators' => [ [ 'name' => 'not_empty', ], [ 'name' => 'string_length', 'options' => [ 'min' => 8 ], ], ], ], ]); $inputFilter->setData($_POST); echo $inputFilter->isValid() ? 'Valid form' : 'Invalid form'; The factory may be used to create not only Input instances, but also nested InputFilter s, allowing you to create validation and filtering rules for hierarchical data sets. Finally, the default InputFilter implementation is backed by a Factory . This means that when calling add() , you can provide a specification that the Factory understands, and it will create the appropriate object. You may create either Input or InputFilter objects in this fashion. use Zend\\InputFilter\\InputFilter; $filter = new InputFilter(); // Adding a single input $filter->add([ 'name' => 'username', 'required' => true, 'validators' => [ [ 'name' => 'not_empty', ], [ 'name' => 'string_length', 'options' => [ 'min' => 5 ], ], ], ]); // Adding another input filter what also contains a single input. Merging both. $filter->add([ 'type' => 'Zend\\InputFilter\\InputFilter', 'password' => [ 'name' => 'password', 'required' => true, 'validators' => [ [ 'name' => 'not_empty', ], [ 'name' => 'string_length', 'options' => [ 'min' => 8 ], ], ], ], ]); The merge() method may be used on an InputFilterInterface instance in order to add two or more filters to each other, effectively allowing you to create chains of filters. This is especially useful in object hierarchies that define a generic set of validation rules on the base object and build on these to create more specific rules. In the example below, an InputFilter is built creating name and email properties, allowing them to be re-used elsewhere. When the isValid() method is called on the object, all of the merged filters are run against the calling object in order to validate the internal properties based on our compound set of filters. use Zend\\InputFilter\\InputFilter; /** * Filter to ensure a name property is set and > 8 characters */ class NameInputFilter extends InputFilter { /** Filter body goes here **/ } /** * Filter to ensure an email property is set and > 8 characters and is valid */ class EmailInputFilter extends InputFilter { /** Filter body goes here **/ } class SimplePerson { /** Member variables omitted for brevity **/ /** @var InputFilter */ protected $inputFilter; /** * Retrieve input filter * * @return InputFilter */ public function getInputFilter() { if (! $this->inputFilter) { // Create a new input filter $this->inputFilter = new InputFilter(); // Merge our inputFilter in for the email property $this->inputFilter->merge(new EmailInputFilter()); // Merge our inputFilter in for the name property $this->inputFilter->merge(new NameInputFilter()); } return $this->inputFilter; } /** * Set input filter * * @param InputFilterInterface $inputFilter * @return SimplePerson */ public function setInputFilter(InputFilterInterface $inputFilter) { $this->inputFilter = $inputFilter; return $this; } } Also see zend-filter zend-validator","title":"Introduction"},{"location":"intro/#introduction","text":"zend-inputfilter can be used to filter and validate generic sets of input data. For instance, you could use it to filter $_GET or $_POST values, CLI arguments, etc. To pass input data to the InputFilter , use the setData() method; the data must be specified using an associative array. Below is an example on how to validate the data coming from a form using the POST method. use Zend\\InputFilter\\InputFilter; use Zend\\InputFilter\\Input; use Zend\\Validator; $email = new Input('email'); $email->getValidatorChain() ->attach(new Validator\\EmailAddress()); $password = new Input('password'); $password->getValidatorChain() ->attach(new Validator\\StringLength(8)); $inputFilter = new InputFilter(); $inputFilter->add($email); $inputFilter->add($password); $inputFilter->setData($_POST); if ($inputFilter->isValid()) { echo \"The form is valid\\n\"; } else { echo \"The form is not valid\\n\"; foreach ($inputFilter->getInvalidInput() as $error) { print_r($error->getMessages()); } } In this example, we validated the email and password values. The email must be a valid address and the password must be composed of at least 8 characters. If the input data are not valid, we report the list of invalid input using the getInvalidInput() method. You can add validators to each input using the attach() method for each validator chain. It is also possible to specify a \"validation group\", a subset of the data to be validated; this may be done using the setValidationGroup() method. You can specify the list of the input names as an array or as individual parameters. // As individual parameters $inputFilter->setValidationGroup('email', 'password'); // or as an array of names $inputFilter->setValidationGroup(['email', 'password']); You can validate and/or filter the data using the InputFilter . To filter data, use the getFilterChain() method of individual Input instances, and attach filters to the returned filter chain. Below is an example that uses filtering without validation. use Zend\\InputFilter\\Input; use Zend\\InputFilter\\InputFilter; $input = new Input('foo'); $input->getFilterChain() ->attachByName('stringtrim') ->attachByName('alpha'); $inputFilter = new InputFilter(); $inputFilter->add($input); $inputFilter->setData([ 'foo' => ' Bar3 ', ]); echo \"Before:\\n\"; echo $inputFilter->getRawValue('foo') . \"\\n\"; // the output is ' Bar3 ' echo \"After:\\n\"; echo $inputFilter->getValue('foo') . \"\\n\"; // the output is 'Bar' The getValue() method returns the filtered value of the 'foo' input, while getRawValue() returns the original value of the input. We also provide Zend\\InputFilter\\Factory to allow initialization of the InputFilter based on a configuration array or Traversable object. Below is an example where we create a password input value with the same constraints proposed before (a string with at least 8 characters): use Zend\\InputFilter\\Factory; $factory = new Factory(); $inputFilter = $factory->createInputFilter([ 'password' => [ 'name' => 'password', 'required' => true, 'validators' => [ [ 'name' => 'not_empty', ], [ 'name' => 'string_length', 'options' => [ 'min' => 8 ], ], ], ], ]); $inputFilter->setData($_POST); echo $inputFilter->isValid() ? 'Valid form' : 'Invalid form'; The factory may be used to create not only Input instances, but also nested InputFilter s, allowing you to create validation and filtering rules for hierarchical data sets. Finally, the default InputFilter implementation is backed by a Factory . This means that when calling add() , you can provide a specification that the Factory understands, and it will create the appropriate object. You may create either Input or InputFilter objects in this fashion. use Zend\\InputFilter\\InputFilter; $filter = new InputFilter(); // Adding a single input $filter->add([ 'name' => 'username', 'required' => true, 'validators' => [ [ 'name' => 'not_empty', ], [ 'name' => 'string_length', 'options' => [ 'min' => 5 ], ], ], ]); // Adding another input filter what also contains a single input. Merging both. $filter->add([ 'type' => 'Zend\\InputFilter\\InputFilter', 'password' => [ 'name' => 'password', 'required' => true, 'validators' => [ [ 'name' => 'not_empty', ], [ 'name' => 'string_length', 'options' => [ 'min' => 8 ], ], ], ], ]); The merge() method may be used on an InputFilterInterface instance in order to add two or more filters to each other, effectively allowing you to create chains of filters. This is especially useful in object hierarchies that define a generic set of validation rules on the base object and build on these to create more specific rules. In the example below, an InputFilter is built creating name and email properties, allowing them to be re-used elsewhere. When the isValid() method is called on the object, all of the merged filters are run against the calling object in order to validate the internal properties based on our compound set of filters. use Zend\\InputFilter\\InputFilter; /** * Filter to ensure a name property is set and > 8 characters */ class NameInputFilter extends InputFilter { /** Filter body goes here **/ } /** * Filter to ensure an email property is set and > 8 characters and is valid */ class EmailInputFilter extends InputFilter { /** Filter body goes here **/ } class SimplePerson { /** Member variables omitted for brevity **/ /** @var InputFilter */ protected $inputFilter; /** * Retrieve input filter * * @return InputFilter */ public function getInputFilter() { if (! $this->inputFilter) { // Create a new input filter $this->inputFilter = new InputFilter(); // Merge our inputFilter in for the email property $this->inputFilter->merge(new EmailInputFilter()); // Merge our inputFilter in for the name property $this->inputFilter->merge(new NameInputFilter()); } return $this->inputFilter; } /** * Set input filter * * @param InputFilterInterface $inputFilter * @return SimplePerson */ public function setInputFilter(InputFilterInterface $inputFilter) { $this->inputFilter = $inputFilter; return $this; } } Also see zend-filter zend-validator","title":"Introduction"},{"location":"optional-input-filters/","text":"Optional Input Filters Available since version 2.8.0 Normally, input filters are required , which means that if you compose them as a subset of another input filter (e.g., to validate a subset of a larger set of data), and no data is provided for that item, or an empty set of data is provided, then the input filter will consider the data invalid. If you want to allow a set of data to be empty, you can use Zend\\InputFilter\\OptionalInputFilter . To illustrate this, let's consider a form where a user provides profile information. The user can provide an optional \"title\" and a required \"email\", and optionally details about a project they lead, which will include the project title and a URL, both of which are required if present. First, let's create an OptionalInputFilter instance for the project data: $projectFilter = new OptionalInputFilter(); $projectFilter->add([ 'name' => 'project_name', 'required' => true, ]); $projectFilter->add([ 'name' => 'url', 'required' => true, 'validators' => [ ['type' => 'uri'], ], ]); Now, we'll create our primary input filter: $profileFilter = new InputFilter(); $profileFilter->add([ 'name' => 'title', 'required' => false, ]); $profileFilter->add([ 'name' => 'email', 'required' => true, 'validators' => [ ['type' => 'EmailAddress'], ], ]); // And, finally, compose our project sub-filter: $profileFilter->add($projectFilter, 'project'); With this defined, we can now validate the following sets of data, presented in JSON for readability: Just profile information: { \"email\": \"user@example.com\", \"title\": \"Software Developer\" } null project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": null } Empty project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": {} } Valid project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": { \"project_name\": \"zend-inputfilter\", \"url\": \"https://github.com/zend-inputfilter\", } }","title":"Optional Input Filters"},{"location":"optional-input-filters/#optional-input-filters","text":"Available since version 2.8.0 Normally, input filters are required , which means that if you compose them as a subset of another input filter (e.g., to validate a subset of a larger set of data), and no data is provided for that item, or an empty set of data is provided, then the input filter will consider the data invalid. If you want to allow a set of data to be empty, you can use Zend\\InputFilter\\OptionalInputFilter . To illustrate this, let's consider a form where a user provides profile information. The user can provide an optional \"title\" and a required \"email\", and optionally details about a project they lead, which will include the project title and a URL, both of which are required if present. First, let's create an OptionalInputFilter instance for the project data: $projectFilter = new OptionalInputFilter(); $projectFilter->add([ 'name' => 'project_name', 'required' => true, ]); $projectFilter->add([ 'name' => 'url', 'required' => true, 'validators' => [ ['type' => 'uri'], ], ]); Now, we'll create our primary input filter: $profileFilter = new InputFilter(); $profileFilter->add([ 'name' => 'title', 'required' => false, ]); $profileFilter->add([ 'name' => 'email', 'required' => true, 'validators' => [ ['type' => 'EmailAddress'], ], ]); // And, finally, compose our project sub-filter: $profileFilter->add($projectFilter, 'project'); With this defined, we can now validate the following sets of data, presented in JSON for readability: Just profile information: { \"email\": \"user@example.com\", \"title\": \"Software Developer\" } null project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": null } Empty project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": {} } Valid project provided: { \"email\": \"user@example.com\", \"title\": \"Software Developer\", \"project\": { \"project_name\": \"zend-inputfilter\", \"url\": \"https://github.com/zend-inputfilter\", } }","title":"Optional Input Filters"},{"location":"specs/","text":"Specifications Zend\\InputFilter allows configuration-driven creation of input filters via Zend\\InputFilter\\InputFilterAbstractServiceFactory . This abstract factory is responsible for creating and returning an appropriate input filter given named configuration under the top-level configuration key input_filter_specs . It is registered with Zend\\InputFilter\\InputFilterPluginManager , allowing you to pull the input filter via that plugin manager. A side effect is that forms pulled from Zend\\Form\\FormElementManager can use these named input filters. Setup When using zend-mvc version 2 releases, this functionality is disabled by default. To enable it, you must add the Zend\\InputFilter\\InputFilterAbstractServiceFactory abstract factory to the Zend\\InputFilter\\InputFilterPluginManager configuration, which is under the input_filters configuration key. return array( 'input_filters' => array( 'abstract_factories' => array( 'Zend\\InputFilter\\InputFilterAbstractServiceFactory' ), ), ); For Expressive when using the configuration manager, and for zend-mvc v3 releases, the functionality is enabled by default, assuming you are using the component installer . Example In the following code, we define configuration for an input filter named foobar : return [ 'input_filter_specs' => [ 'foobar' => [ [ 'name' => 'name', 'required' => true, 'filters' => [ [ 'name' => 'Zend\\Filter\\StringTrim', 'options' => [], ], ], 'validators' => [], 'description' => 'Hello to name', 'allow_empty' => false, 'continue_if_empty' => false, ], ], ], ]; When creating a controller, we might then pull the InputFilterManager , and retrieve the foobar input filter we've defined in order to inject it: use Zend\\ServiceManager\\FactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class MyValidatingControllerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $controllers) { // Retrieve the application service manager $services = $controllers->getServiceLocator(); // Retrieve the InputFilterManager $filters = $services->get('InputFilterManager'); // Instantiate the controller and pass it the foobar input filter return new MyValidatingController($filters->get('foobar')); } } And you can use it as you already did with other input filters: $inputFilter->setData([ 'name' => 'test', ]); if (! $inputFilter->isValid()) { echo 'Data invalid'; }","title":"Specifications"},{"location":"specs/#specifications","text":"Zend\\InputFilter allows configuration-driven creation of input filters via Zend\\InputFilter\\InputFilterAbstractServiceFactory . This abstract factory is responsible for creating and returning an appropriate input filter given named configuration under the top-level configuration key input_filter_specs . It is registered with Zend\\InputFilter\\InputFilterPluginManager , allowing you to pull the input filter via that plugin manager. A side effect is that forms pulled from Zend\\Form\\FormElementManager can use these named input filters.","title":"Specifications"},{"location":"specs/#setup","text":"When using zend-mvc version 2 releases, this functionality is disabled by default. To enable it, you must add the Zend\\InputFilter\\InputFilterAbstractServiceFactory abstract factory to the Zend\\InputFilter\\InputFilterPluginManager configuration, which is under the input_filters configuration key. return array( 'input_filters' => array( 'abstract_factories' => array( 'Zend\\InputFilter\\InputFilterAbstractServiceFactory' ), ), ); For Expressive when using the configuration manager, and for zend-mvc v3 releases, the functionality is enabled by default, assuming you are using the component installer .","title":"Setup"},{"location":"specs/#example","text":"In the following code, we define configuration for an input filter named foobar : return [ 'input_filter_specs' => [ 'foobar' => [ [ 'name' => 'name', 'required' => true, 'filters' => [ [ 'name' => 'Zend\\Filter\\StringTrim', 'options' => [], ], ], 'validators' => [], 'description' => 'Hello to name', 'allow_empty' => false, 'continue_if_empty' => false, ], ], ], ]; When creating a controller, we might then pull the InputFilterManager , and retrieve the foobar input filter we've defined in order to inject it: use Zend\\ServiceManager\\FactoryInterface; use Zend\\ServiceManager\\ServiceLocatorInterface; class MyValidatingControllerFactory implements FactoryInterface { public function createService(ServiceLocatorInterface $controllers) { // Retrieve the application service manager $services = $controllers->getServiceLocator(); // Retrieve the InputFilterManager $filters = $services->get('InputFilterManager'); // Instantiate the controller and pass it the foobar input filter return new MyValidatingController($filters->get('foobar')); } } And you can use it as you already did with other input filters: $inputFilter->setData([ 'name' => 'test', ]); if (! $inputFilter->isValid()) { echo 'Data invalid'; }","title":"Example"},{"location":"unfiltered-data/","text":"Unfiltered Data Available since version 2.10.0 On input filters, there are several methods for retrieving the data: getValues() will return all known values after filtering them. getRawValues() will return all known values with no filtering applied. getUnknown() returns the set of all unknown values (values with no corresponding input or input filter). At times, particularly when working with collections, you may want access to the complete set of original data provided to the input filter. This can be accomplished by merging the sets returned by getRawValues() and getUnknown() when working with normal input filters, but this approach breaks down when working with collections. Version 2.10.0 introduces a new interface, Zend\\InputFilter\\UnfilteredDataInterface , for dealing with this situation. Zend\\InputFilter\\BaseInputFilter , which forms the parent class for all shipped input filter implementations, implements the interface, which consists of the following methods: interface UnfilteredDataInterface { /** * @return array|object */ public function getUnfilteredData() { return $this->unfilteredData; } /** * @param array|object $data * @return $this */ public function setUnfilteredData($data) { $this->unfilteredData = $data; return $this; } } The setUnfilteredData() method is called by setData() with the full $data provided to that method, ensuring that getUnfilteredData() will always provide the original data with which the input filter was initialized, with no filtering applied.","title":"Unfiltered Data"},{"location":"unfiltered-data/#unfiltered-data","text":"Available since version 2.10.0 On input filters, there are several methods for retrieving the data: getValues() will return all known values after filtering them. getRawValues() will return all known values with no filtering applied. getUnknown() returns the set of all unknown values (values with no corresponding input or input filter). At times, particularly when working with collections, you may want access to the complete set of original data provided to the input filter. This can be accomplished by merging the sets returned by getRawValues() and getUnknown() when working with normal input filters, but this approach breaks down when working with collections. Version 2.10.0 introduces a new interface, Zend\\InputFilter\\UnfilteredDataInterface , for dealing with this situation. Zend\\InputFilter\\BaseInputFilter , which forms the parent class for all shipped input filter implementations, implements the interface, which consists of the following methods: interface UnfilteredDataInterface { /** * @return array|object */ public function getUnfilteredData() { return $this->unfilteredData; } /** * @param array|object $data * @return $this */ public function setUnfilteredData($data) { $this->unfilteredData = $data; return $this; } } The setUnfilteredData() method is called by setData() with the full $data provided to that method, ensuring that getUnfilteredData() will always provide the original data with which the input filter was initialized, with no filtering applied.","title":"Unfiltered Data"}]}